// ==============================================================
// RTL generated by AutoESL - High-Level Synthesis System (C, C++, SystemC)
// Version: 2012.1
// Copyright (C) 2012 Xilinx Inc. All rights reserved.
// 
// ===========================================================

#include "top_n_outlier_pruning_block.h"
#include "AESL_pkg.h"

using namespace std;

namespace ap_rtl {

const sc_lv<32> top_n_outlier_pruning_block::ap_const_lv32_0 = "00000000000000000000000000000000";
const sc_logic top_n_outlier_pruning_block::ap_const_logic_1 = SC_LOGIC_1;
const sc_logic top_n_outlier_pruning_block::ap_const_logic_0 = SC_LOGIC_0;

top_n_outlier_pruning_block::top_n_outlier_pruning_block(sc_module_name name) : sc_module(name), mVcdFile(0) {

    SC_METHOD(thread_ap_return);

    SC_THREAD(thread_hdltv_gen);
    sensitive << ( ap_virtual_clock.pos() );

    static int apTFileNum = 0;
    stringstream apTFilenSS;
    apTFilenSS << "top_n_outlier_pruning_block_sc_trace_" << apTFileNum ++;
    string apTFn = apTFilenSS.str();
    mVcdFile = sc_create_vcd_trace_file(apTFn.c_str());
    mVcdFile->set_time_unit(-12);
    const char* dump_vcd = std::getenv("AP_WRITE_VCD");
    if (dump_vcd) {
    sc_trace(mVcdFile, dummy, "(port)dummy");
    sc_trace(mVcdFile, ap_return, "(port)ap_return");

    }
}

top_n_outlier_pruning_block::~top_n_outlier_pruning_block() {
    if (mVcdFile) 
        sc_close_vcd_trace_file(mVcdFile);

}

void top_n_outlier_pruning_block::thread_ap_return() {
    ap_return = ap_const_lv32_0;
}

void top_n_outlier_pruning_block::thread_hdltv_gen() {
    const char* dump_tv = std::getenv("AP_WRITE_TV");
    if (dump_tv && string(dump_tv) == "off") return;

    wait();

    ofstream mAeslHdltvinHandle("top_n_outlier_pruning_block.autohdltvin.dat");
    ofstream mAeslHdltvoutHandle("top_n_outlier_pruning_block.autohdltvout.dat");
    int ap_cycleNo = 0;
    while (1) {
        wait();
        mAeslHdltvinHandle << "[[cycle]] " << ap_cycleNo << endl;
        mAeslHdltvoutHandle << "[[cycle]] " << ap_cycleNo << endl;
        mAeslHdltvinHandle << "[dummy]" << endl;
        mAeslHdltvinHandle << dummy.read() << endl;
        mAeslHdltvinHandle << "[/dummy]" << endl;
        mAeslHdltvoutHandle << "[ap_return]" << endl;
        mAeslHdltvoutHandle << ap_return.read() << endl;
        mAeslHdltvoutHandle << "[/ap_return]" << endl;
        mAeslHdltvinHandle << "[[/cycle]]" << endl;
        mAeslHdltvoutHandle << "[[/cycle]]" << endl;
        ap_cycleNo++;
    }
}

}

