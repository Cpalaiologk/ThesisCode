% We have "m" vectors of size "d". We want to find the top "N" outliers by 
% inspecting the "k" nearest neighbours for each vector. We work in blocks of
% size "b".

% Worst case,
%     = ceil(m/b) * (O(b) + O(b) + O(b*k) + O(b*k) + O(b) + m*(b-1)*(O(d) + O(k)) + O(b+N) + O(b+N) + O((b+N)*log(b+N)) + O(b+N) + O(N) + O(N))
%    := ceil(m/b) * (3*O(b) + 2*O(b*k) + m*(b-1)*(O(d) + O(k)) + 3*O(b+N) + O((b+N)*log(b+N)) + 2*O(N))
%    := ceil(m/b) * (O(b) + O(b*k) + m*b*(O(d) + O(k)) + O(b+N) + O((b+N)*log(b+N)) + O(N))
% k > 1, therefore:
%    := ceil(m/b) * (O(b*k) + m*b*(O(d) + O(k)) + O(b+N) + O((b+N)*log(b+N)) + O(N))
% N > 0, therefore:
%    := ceil(m/b) * (O(b*k) + m*b*(O(d) + O(k)) + O(b+N) + O((b+N)*log(b+N)))
%    := ceil(m/b) * (O(b*k) + m*b*(O(d) + O(k)) + O((b+N)*log(b+N)))
% m >> k, therefore:
%    := ceil(m/b) * (m*b*(O(d) + O(k)) + O((b+N) log(b+N)))
%    := ceil(m/b) * (O(m*b*(d+k)) + O((b+N)*log(b+N)))
%    := (m/b) * (O(m*b*(d+k)) + O((b+N)*log(b+N)))
%    := (O(m^2*(d+k)) + O(m(1+N/b)*log(b+N)))

% If we keep neighbours sorted,
%     = ceil(m/b) * (O(b) + O(b) + O(b*k) + O(b*k) + O(b) + m*(b-1)*(O(d) + O(k)) + O(b+N) + O(b+N) + O((b+N)*log(b+N)) + O(b+N) + O(N) + O(N))

function [O, OF] = TopN_Outlier_Pruning_Block_ORIGINAL(X, k, N, block_size)
    n  = size (X,1);
    OF = zeros(1,N);
    O  = OF;
    
    c = 0;
    count = 0;
    while (n-count > 0) % This loop will execute "ceil(m/b)" times
        B = zeros(1, block_size); % O(b)
        B = (count+1 : count+block_size); % O(b)
        count = count + block_size;
        
        if count <= n
            sizeB = block_size;
        else
            sizeB = n - (count - block_size);
        end
        
        neighbours      = zeros(sizeB,k); % O(b*k)
        neighbours_dist = zeros(sizeB,k); % O(b*k)
        score           = zeros(1,sizeB); % O(b)

        l = 1;
        for i = 1 : n % This loop will execute "m" times
            for j = 1 : sizeB % This loop will execute "b-1" times
                if i ~= B(j) && B(j) ~= 0 % In the worst case, no vectors will ever be removed from the block
                    d = euclidean_dist_squared(X(i,:), X(B(j),:)); % O(d)

                    if l>1 && l<=k+1 && neighbours(j,l-1) == 0
                        l = l-1;
                    elseif l<k && neighbours(j,l) ~= 0
                        l = l+1;
                    end

                    if l <= k
                        neighbours     (j,l) = i;
                        neighbours_dist(j,l) = d;
                        if l == k
                            score(j) = mean(neighbours_dist(j,:), 2); % O(k)
                        end
                    else
                        [maxd,maxi] = max(neighbours_dist(j,:)); % O(k)

                        if d < maxd
                            neighbours     (j,maxi) = i;
                            neighbours_dist(j,maxi) = d;

                            score(j) = (score(j)*k - maxd + d)/k;
                            if score(j) <= 0
                                score(j) = max(mean(neighbours_dist(j,:),2),0);
                            end
                        end
                    end

                    if l >= k && score(j) < c % In the worst case, no vectors will ever be removed from the block
                        B(j) = 0;
                        score(j) = 0;
                    end
                end
            end
            l = l+1;
        end

        BO  = [B(1:sizeB) O]; % O(b+N)
        BOF = [score OF]; % O(b+N)
        [BOF,index] = sort(BOF, 'descend'); % O((b+N) log(b+N))
        BO = BO(index); % O(b+N)

        O  = BO(1:N); % O(N)
        OF = BOF(1:N); % O(N)

        c = OF(N);
    end
